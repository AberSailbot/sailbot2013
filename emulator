#!/usr/bin/env python
import socket
import sys
import re
import time
import traceback
import subprocess
import threading

from sailbot import Boat

#boat = Boat()
logfile = 'log/' + '-'.join(['log-taken-on'] + time.asctime().split()[:-1])

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_address = ('localhost', 5555)
sock.bind(server_address)

DEBUG = False

'''debug
events = [
          {
            #events with arguments
            'set rudder': boat.arduino.set_rudder,
            'set sail': boat.arduino.set_sail,
            'set waypointnorthing': boat.set_waypoint_northing,
            'set waypointeasting': boat.set_waypoint_easting,
            'set waypointnum': boat.set_waypoint_number,
            'set waypointdistance': boat.set_waypoint_distance,
            'set waypointheading': boat.set_waypoint_heading,
            'set targetheading': boat.set_target_heading,
            'set targetdistance': boat.set_target_distance
          },
          {
            #events without arguments
            'get compass': boat.arduino.get_compass,
            'get wind_dir': boat.get_wind_average,
            'get northing': lambda: boat.gps.position.lat,
            'get easting': lambda: boat.gps.position.long,
            'get waypointnum': boat.get_waypoint_number,
          }
        ]
'''

def get_event(s):
    for e in events[0]:
        match = re.match(e, s)
        if match:
            arg = s.split()[-1]
            return events[0][e](float(arg))
    for e in events[1]:
        match = re.match(e, s)
        if match:
            return events[1][e]()

def log(message, col=32):
    print  '[\033[1;{col}m{}\033[0m]: {}'.format(time.time(), message, col=col)

def spawn_sailbotlogic():
    return subprocess.Popen(['eog'],
                            stdout=subprocess.PIPE, 
                            stderr=subprocess.STDOUT)

class InputThread(threading.Thread):
    def run(self, connection, inputQueue, outputQueue, sockLock, queueLock):
        data = ''
        while True:
            with sockLock:
                c = connection.recv(1)
                if c == '\n':
                    with queueLock:
                        inputQueue.append(data)
                        log('received "%s"' % data, col=33)
                    data = ''
                else:
                    data += c

class OutputThread(threading.Thread):
    def run(self, connection, inputQueue, outputQueue, sockLock, queueLock):
        while True:
            if len(outputQueue) > 0:
                print "heehehehehe2"
                with queueLock:
                    if msg is not None:
                        connection.sendall(str(msg) + '\n')
                        log('Sent : ' + str(msg), col=31)
                    else:
                        log('Didn\'t send a message for a set')

log('starting up on %s port %s' % server_address)
while True:
    sock.listen(1)
    connection, client_address = sock.accept()
    inputQueue = []
    outputQueue = []
    sockLock = threading.Lock()
    queueLock = threading.Lock()
    try:
        inputThread = InputThread()
        inputThread.run(connection, inputQueue, outputQueue, sockLock, queueLock)
        outputThread = OutputThread()
        outputThread.run(connection, inputQueue, outputQueue, sockLock, queueLock)
        while True:
            '''debug
            if boat.gps.shouldLog:
                boat.log(logfile)
                boat.gps.shouldLog = False
            '''
            with queueLock:
                if len(inputQueue) > 0:
                    data = inputQueue[0]
                    try:
                        #msg = get_event(data)
                        print 'getting', data
                        msg = 'hello'
                        outputQueue.append(msg)
                    except:
                        print traceback.format_exc()
                        if DEBUG:
                            sys.exit(1)
                        else:
                            #try to keep going if an error occurred
                            print 'no debug'
                            break

                else:
                    break
    finally:
        connection.close()
